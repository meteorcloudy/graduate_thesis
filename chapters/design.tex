% !Mode:: "TeX:UTF-8"
% !Mode:: "TeX:UTF-8"

\chapter{算法思想与设计}
本文的算法与\cite{chen2012faster}中的相似，都是基于Whidden的参数算法\citeup{whidden2010fast}改进而来。因此，在这里有必要先简单介绍Whidden算法的内容，并给出简要的时间复杂度分析。之后，会详细介绍本文的改进思路，并给出详细的方法和步骤。

\section{Whidden的参数算法\citeup{whidden2010fast}}
\subsection{算法概述} \label{whidden_algo}

Whidden的算法所解决的正是本文在第\ref{problem}节中所提出的问题。设$MAF(T_1,F_2,k)$为针对此问题的判定函数，$T_1$代表第一棵进化树，$F_2$代表$T_2$删除某个边集后所得的森林，$k$是一个非负整数。若$F_2$能够在删除至多$k$条边后变成$T_1,T_2$的最大一致森林，则$MAF(T_1,F_2,k)$返回$true$，否则返回$false$。初始时，$F_2 = T_2$。求解rSPR距离，只需要从$0$开始枚举$k$的值，直到$MAF(T_1,T_2,k)$返回$true$。因为时间复杂度是关于$k$的指数，所以相对于计算$MAF(T_1,T_2,k)$，计算rSPR距离只会在时间复杂度的常数上有所增加。算法采用递归的思想，$MAF$函数的具体步骤如下：

\begin{enumerate}
	\item 如果$k<0$，返回$false$
	\item \label{step2}如果在$T_1$中存在一对兄弟叶节点$a,b$，并且它们在$F_2$中的对应节点也是兄弟叶节点，那么就合并$a,b$，然后把它们的在$T_1,F_2$中的父节点作为对应的叶节点。重复此步骤，直至没有节点可以合并。
	\item 如果在$F_2$中存在只有一个节点的子树$x$，则将$x$从$T_1,F_2$中移除。重复此步骤，直至没有节点可以移除。此时如果产生新的可以合并的兄弟叶节点，则转至\ref{step2}，否则继续。
	\item 如果$F_2$为空，返回$true$
	\item \label{step5}任意选择$T_1$中的一对兄弟叶节点$a,b$（注意到此时$a,b$在$F_2$中一定不是兄弟叶节点），分三种情况讨论（如图\ref{3cases}）：
	\begin{enumerate}
		\item Case 1\label{case1}：若$a,b$在$F_2$中属于不同的连通分量。可以证明\citeup{whidden2013fixed}，$a$的父边$e_a$和$b$的父边$e_b$两条边中至少有一条需要删除。对于两种情况下修改后的$F_2' = F_2 - \{e_a\}$和$F_2' = F_2 - \{e_b\}$，分别调用两次$MAF(T_1,F_2',k-1)$。只要有任意一次结果为$true$，则返回$true$，否则返回$false$。
		\item Case 2\label{case2}：若$a,b$在$F_2$中连通，并且$a,b$之间有且只有一个悬挂节点$p$。可以证明\citeup{whidden2013fixed}，一定存在最优解$E \subset E_{T_2}$，使得$T_2 - E$是$T_1,T_2$的MAF，并且$e_p \in E$。因此，只需要直接修改$F_2$，得到$F_2' = F_2-\{e_p\}$。若$MAF(T_1,F_2',k-1)$结果为$true$，则返回$true$，否则返回$false$。
		\item Case 3\label{case3}：若$a,b$在$F_2$中连通，并且$a,b$之间有至少两个悬挂节点。设$a,b$之间所有悬挂节点的集合为$P=\{p_1,p_2,...,p_m\},m \ge 2$。可以证明\citeup{whidden2013fixed}，一定存在最优解$E \subset E_{T_2}$，使得$T_2 - E$是$T_1,T_2$的MAF，并且$e_a \in E$或者$e_b \in E$或者对于所有$1 \le i \le m$，有$e_{p_i} \in E$。因此，分别修改$F_2$得到$F_2' = F_2 - \{e_a\}$、$F_2' = F_2 - \{e_b\}$和$F_2' = F_2 - E_P$（$E_P$为P中所有节点对应的父边的集合），然后分别调用两次$MAF(T_1,F_2',k-1)$和一次$MAF(T_1,F_2',k-m)$。只要有任意一次结果为$true$，则返回$true$，否则返回$false$。
	\end{enumerate}  
\end{enumerate}
\pic[htbp]{Whidden算法第\ref{step5}步的三种情况}{width=0.74\textwidth}{3cases}

\subsection{时间复杂度分析}

不难看出，适当地设计数据结构，Whidden算法中前四步可以在$O(n)$的时间内完成。因此，我们关键需要分析搜索树的大小，而搜索树的大小与参数$k$有直接关系。设$C(k)$为参数为$k$时最坏情况下搜索树的大小。根据第\ref{step5}步中的三种情况，我们可以得到下面三个不等式：
\begin{enumerate}
	\item 若$a,b$在$F_2$中属于不同的连通分量。
	\begin{equation*}
		C(k) \le 2C(k-1)
	\end{equation*}
	\item 若$a,b$在$F_2$中连通，并且$a,b$之间有且只有一个悬挂节点。
	\begin{equation*}
		C(k) \le C(k-1)
	\end{equation*}
	\item 若$a,b$在$F_2$中连通，并且$a,b$之间有至少两个悬挂节点。
	\begin{equation*}
		C(k) \le 2C(k-1) + C(k-m),~m \ge 2
	\end{equation*}
\end{enumerate}

可以看出，$C(k)$的最坏情况出现在第3种情况$m = 2$时，此时有
\begin{equation*}
C(k) \le 2C(k-1) + C(k-2)
\end{equation*}

设$C(k)=\alpha ^ k$，带入可得
\begin{equation*}
 1 = 2 \alpha ^ {-1} + \alpha ^ {-2}
\end{equation*}

解得$\alpha = 1 + \sqrt{2} \approx 2.42$，因此Whidden参数算法复杂度为$O(2.42^kn)$。Whidden的算法最大贡献在于发现了Case 2中当$a,b$直接只有$1$个悬挂节点便可以直接删除其父边的规律。而该算法的限制则在于Case 3，本文正是试图寻找方法改进Case 3的最坏情况，具体内容将在下一节讨论。

\section{改进思路}
显然，当叶节点个数$n$小于$3$时，两棵进化树的rSPR距离一定是$0$，因此在后面的讨论中，我们假设$n \ge 3$。为了改进Whidden的算法，我们试图在Whidden所利用的两个兄弟叶节点的基础之上加入更多的节点，以此获取更多的信息用以改进算法。一种自然的想法是在$T_1$中寻找形如图\ref{3and4}中(a)的结构。但(a)所表示的结构并非在所有进化树中都会出现，例如一棵叶节点个数为$4$的满二叉树。然而可以证明，若(a)中的结构不存在，一定存在形如图\ref{3and4}中(b)所表示的结构。
\clearpage
\pic[htbp]{两种结构}{width=0.7\textwidth}{3and4}

\begin{yinli}\label{yinli1}
对于任意一棵叶节点数大于$3$的进化树$T$，存在下面至少一种情况：
\begin{itemize}
	\item 存在$T$的三个叶节点$a,b,c$，满足$a,b$是兄弟节点，并且$a,b$的父节点与$c$是兄弟节点（图\ref{3and4}~(a)）
	\item 存在$T$的四个叶节点$a,b,c,d$，满足$a,b$是兄弟节点，$c,d$是兄弟节点，并且$a,b$的父节点与$c,d$的父节点是兄弟节点（图\ref{3and4}~(b)）
\end{itemize}
\end{yinli}

\textbf{证明：}不妨设$a$是离$T$的根节点最远的叶节点，根据进化树的定义，一定存在$a$的兄弟节点$b$。（图\ref{3and4_pro}~(a)）设$p$为$a,b$的父节点的兄弟节点，因为$a$离根节点的距离最远，那么以$p$为根节点的子树$T_p$只有两种可能。
\begin{itemize}
	\item $p$为叶节点，如图\ref{3and4_pro}~(b)，此时出现引理\ref{yinli1}中第一种情况
	\item $p$不为叶节点，则$p$一定有且只有两个叶节点，如图\ref{3and4_pro}~(c)，此时出现引理\ref{yinli1}中第二种情况
\end{itemize}

\pic[htbp]{引理\ref{yinli1}证明}{width=0.9\textwidth}{3and4_pro}

于是，基于引理\ref{yinli1}我们可以改进Whidden算法的第\ref{step5}步。

\section{改进算法}
本文改进算法的前四步与第\ref{whidden_algo}节中叙述的完全一致，主要针对第\ref{step5}步进行优化。为了方便叙述，我们定义\textbf{$\rho(a,b)$等于从节点$a$到节点$b$的路径上的边数减$2$，即节点$a,b$之间悬挂节点的个数。}

在详细叙述本文的改进方法之前，我们再明确一下当$T_1,F_2$经过前四步的处理后所具有的两点性质：\label{2point}

\begin{enumerate}
	\item $T_1$中的任意一对兄弟叶节点$a,b$在$F_2$中一定不是兄弟节点。换句话说，$a,b$在$F_2$中要么不连通，要么连通但$\rho(a,b) \ge 1$。
	\item $T_1,F_2$中的任意一个叶节点$x$都不可能是某棵树的根节点。这意味着任意叶节点$x$的父边$e_x$一定存在。
\end{enumerate}

改进算法的第五步首先是在$T_1$中寻找图\ref{3and4_pro}~(a)所表示的结构，这可以通过遍历$T_1$在最多$O(n)$的时间内完成。接下来，我们根据子树$T_p$的两种情况分类讨论。

\subsection{当$p$为叶节点}
\textit{Case 1: }当$p$为叶节点时，我们得到$T_1$中的$3$个叶节点$a,b,c$，使其结构如图\ref{3node}。此时，根据$a,b,c$在$F_2$中的不同形态，我们采取不同的策略。
\pic[htbp]{$T_1$中的$a,b,c$}{width=0.25\textwidth}{3node}

\textit{Case 1.1: }若$a,b$在$F_2$中属于不同的连通分量，此时出现Whidden算法第\ref{step5}步中的情况\ref{case1}，用相同方法处理。\\

\textit{Case 1.2: }若$a,b$在$F_2$中属于相同的连通分量，但$\rho(a,b)=1$时，此时出现Whidden算法第\ref{step5}步中的情况\ref{case2}，也用相同方法处理。
\clearpage

\textit{Case 1.3: }若$a,b$在$F_2$中属于相同的连通分量，且满足$\rho(a,b) \ge 2$，但$a,b$与$c$不属于同一连通分量（如图\ref{case_1_3}）。
\pic[htbp]{\textit{Case 1.3}中的$a,b,c$}{width=0.45\textwidth}{case_1_3}

设$x$为节点$a$在最终的MAF中的兄弟节点，我们进行如下分类讨论：

\begin{enumerate}
	\item 如果$x = \empty$，
\end{enumerate}

\subsection{当$p$不为叶节点}































% !Mode:: "TeX:UTF-8"
% !Mode:: "TeX:UTF-8"

\chapter{算法思想与设计}
本文的算法与\cite{chen2012faster}中的相似，都是基于Whidden的参数算法\citeup{whidden2010fast}改进而来。因此，在这里有必要先简单介绍Whidden算法的内容，并给出简要的时间复杂度分析。之后，会详细介绍本文的改进思路，并给出详细的方法和步骤。

\section{Whidden的参数算法\citeup{whidden2010fast}}
\subsection{算法概述}

Whidden的算法所解决的正是本文在第\ref{problem}节中所提出的问题。设$MAF(T_1,F_2,k)$为针对此问题的判定函数，$T_1$代表第一棵进化树，$F_2$代表$T_2$删除某个边集后所得的森林，$k$是一个非负整数。若$F_2$能够在删除至多$k$条边后变成$T_1,T_2$的最大一致森林，则$MAF(T_1,F_2,k)$返回$true$，否则返回$false$。初始时，$F_2 = T_2$。求解rSPR距离，只需要从$0$开始枚举$k$的值，直到$MAF(T_1,T_2,k)$返回$true$。因为时间复杂度是关于$k$的指数，所以相对于计算$MAF(T_1,T_2,k)$，计算rSPR距离只会在时间复杂度的常数上有所增加。算法采用递归的思想，$MAF$函数的具体步骤如下：

\begin{enumerate}
	\item 如果$k<0$，返回$false$
	\item \label{step2}如果在$T_1$中存在一对兄弟叶节点$a,b$，并且它们在$F_2$中的对应节点也是兄弟叶节点，那么就合并$a,b$，然后把它们的在$T_1,F_2$中的父节点作为对应的叶节点。重复此步骤，直至没有节点可以合并。
	\item 如果在$F_2$中存在只有一个节点的子树$x$，则将$x$从$T_1,F_2$中移除。重复此步骤，直至没有节点可以移除。此时如果产生新的可以合并的兄弟叶节点，则转至\ref{step2}，否则继续。
	\item 如果$F_2$为空，返回$true$
	\item \label{step5}任意选择$T_1$中的一对兄弟叶节点$a,b$（注意到此时$a,b$在$F_2$中一定不是兄弟叶节点），分三种情况讨论（如图\ref{3cases}）：
	\begin{enumerate}
		\item Case 1\label{case1}：若$a,b$在$F_2$中属于不同的连通分量。可以证明\citeup{whidden2013fixed}，$a$的父边$e_a$和$b$的父边$e_b$两条边中至少有一条需要删除。对于两种情况下修改后的$F_2' = F_2 - \{e_a\}$和$F_2' = F_2 - \{e_b\}$，分别调用两次$MAF(T_1,F_2',k-1)$。只要有任意一次结果为$true$，则返回$true$，否则返回$false$。
		\item Case 2\label{case2}：若$a,b$在$F_2$中连通，并且$a,b$之间有且只有一个悬挂节点$p$。可以证明\citeup{whidden2013fixed}，一定存在最优解$E \subset E_{T_2}$，使得$T_2 - E$是$T_1,T_2$的MAF，并且$e_p \in E$。因此，只需要直接修改$F_2$，得到$F_2' = F_2-\{e_p\}$。若$MAF(T_1,F_2',k-1)$结果为$true$，则返回$true$，否则返回$false$。
		\item Case 3\label{case3}：若$a,b$在$F_2$中连通，并且$a,b$之间有至少两个悬挂节点。设$a,b$之间所有悬挂节点的集合为$P=\{p_1,p_2,...,p_m\},m \ge 2$。可以证明\citeup{whidden2013fixed}，一定存在最优解$E \subset E_{T_2}$，使得$T_2 - E$是$T_1,T_2$的MAF，并且$e_a \in E$或者$e_b \in E$或者对于所有$1 \le i \le m$，有$e_{p_i} \in E$。因此，分别修改$F_2$得到$F_2' = F_2 - \{e_a\}$、$F_2' = F_2 - \{e_b\}$和$F_2' = F_2 - E_P$（$E_P$为P中所有节点对应的父边的集合），然后分别调用两次$MAF(T_1,F_2',k-1)$和一次$MAF(T_1,F_2',k-m)$。只要有任意一次结果为$true$，则返回$true$，否则返回$false$。
	\end{enumerate}  
\end{enumerate}
\pic[htbp]{Whidden算法第\ref{step5}步的三种情况}{width=0.74\textwidth}{3cases}

\subsection{时间复杂度分析}

不难看出，适当地设计数据结构，Whidden算法中前四步可以在$O(n)$的时间内完成。因此，我们关键需要分析搜索树的大小，而搜索树的大小与参数$k$有直接关系。设$C(k)$为参数为$k$时最坏情况下搜索树的大小。根据第\ref{step5}步中的三种情况，我们可以得到下面三个不等式：
\begin{enumerate}
	\item 若$a,b$在$F_2$中属于不同的连通分量。
	\begin{equation*}
		C(k) \le 2C(k-1)
	\end{equation*}
	\item 若$a,b$在$F_2$中连通，并且$a,b$之间有且只有一个悬挂节点。
	\begin{equation*}
		C(k) \le C(k-1)
	\end{equation*}
	\item \label{case3_an}若$a,b$在$F_2$中连通，并且$a,b$之间有至少两个悬挂节点。
	\begin{equation*}
		C(k) \le 2C(k-1) + C(k-m),~m \ge 2
	\end{equation*}
\end{enumerate}

可以看出，$C(k)$的最坏情况出现在第3种情况$m = 2$时，此时有
\begin{equation*}
C(k) \le 2C(k-1) + C(k-2)
\end{equation*}

设$C(k)=\alpha ^ k$，带入可得
\begin{equation*}
 1 = 2 \alpha ^ {-1} + \alpha ^ {-2}
\end{equation*}

解得$\alpha = 1 + \sqrt{2} \approx 2.42$，因此Whidden参数算法复杂度为$O(2.42^kn)$。Whidden的算法最大贡献在于发现了Case 2中当$a,b$直接只有$1$个悬挂节点便可以直接删除其父边的规律。而该算法的限制则在于Case 3，本文正是试图寻找方法改进Case 3的最坏情况，具体内容将在下一节讨论。

\section{改进思路}

\section{详细步骤}


































